/** @addtogroup Network
 *  @{
 */

/**
 * The server running one game. It keeps one world representation, receives
 * command from various clients and sends back commands to execute, in the
 * futur, to concerned clients, and execute them later using the TurnHandler
 * class.
 * @class GameServer
 */

#ifndef __GAME_SERVER_HPP__
# define __GAME_SERVER_HPP__

#include <vector>

#include <game/game.hpp>
#include <game/remote_game_client.hpp>
#include <game/occupants_handler.hpp>
#include <network/server.hpp>
#include <world/world.hpp>
#include <game/replay.hpp>
#include <game/turn_handler.hpp>

class GameServer: public Game, public Server<RemoteGameClient>
{
public:
  GameServer(short port);
  ~GameServer();
  // World* get_world();

  virtual void on_new_client(RemoteGameClient*) override final;
  virtual void on_client_left(RemoteGameClient*) override final;

  void on_entity_created(const Entity* entity);
  /**
   * Send the complete content of the replay contained in the World
   * to the client.
   */
  void send_replay(RemoteGameClient*);
  /**
   * Send a start message to the client telling it to start
   * confirming turns and actions from there.
   */
  void send_start_message(RemoteGameClient*);
  /**
   * Take all futur actions in the turn_handler, if they are not
   * completely validated yet, change their validations_needed value
   * to the current number of occupants, and send them to the client.
   */
  void send_future_actions(RemoteGameClient*);
  /**
   * Send a message to signal all clients that the next turn is now ready to
   * be executed.
   */
  void send_turn();
  /**
   * Send the seed value to one client.
   **/
  void send_seed_value(RemoteGameClient* client);

  void tick();
  // void pause_game();
  // void unpause_game();
  void start_game();
  void seed_world();
  void send_message_to_all(const char* name, const std::string& data);
  void send_order_to_all(const char* name, const google::protobuf::Message& srl);
  /**
   * Called when a turn is done. Validate our next turn and send a TURN
   * command to all clients.
   */
  void on_next_turn(const TurnNb nb);

  void send_new_entity_order(const EntityType type, const Position& pos, const uint16_t team);
  void send_move_order(const std::vector<EntityId> ids, const Position& pos, const bool queue);
  void send_follow_order(const std::vector<EntityId> ids, const EntityId target, const bool queue);
  /**
   * Send an Order to each client, to make each of these entities cast the
   * given ability.
   */
  void send_cast_order(const std::vector<EntityId>& ids, const Position& pos,
                       const uint32_t type, const bool queue);
  void send_cast_order(const std::vector<EntityId>& ids, const EntityId target_id,
                       const uint32_t type, const bool queue);
  void send_cast_order(const std::vector<EntityId>& ids,
                       const uint32_t type, const bool queue);
  /**
   * This will create the initial game
   * state.
   * The iniatial state is generated by associating some actions with the
   * turn number 1.
   * When a new occupant joins (even if the game is not started) it will
   * receive these messages as part of the "replay". If the game is not yet
   * started, the replay is only one turn long.
   * If a player joins later (the game is started), it will still receive
   * the actions associated with the first turn, plus the subsequent game
   * actions.
   */
  void init();
  /**
   * Spawn two waves of entities
   */
  void spawn_waves();
  /**
   * Called whenever we receive a MOVE message from one client.
   * We try to generate a path, if the move is valid, and then
   * send that path action to all clients.
   */
  void on_move_request(Message*);
  /**
   * Called whenever we receive a CAST message from one client.
   */
  void on_cast_request(Message*);
  /**
   * Called whenever we receive a BUILD message from one client.
   * Check if the position is valid and the building can be built (money, the unit actually has this ability, etc).
   */
  void build_callback(Message*);
  /**
   * Called whenever we receive a SPAWN message from one client.  Should
   * check if that unit can actually do that (money, capacity to do it,
   * etc), before returning a DoSpawnEvent.
   */
  void spawn_callback(Message*);

private:
  GameServer(const GameServer&);
  GameServer& operator=(const GameServer&);
  /**
   * Store the already executed Actions, to pass them to save them in a
   * file, and send them to the new occupants when they join a running game.
   */
  Replay replay;
};

#endif // __GAME_SERVER_HPP__
/**#@}*/
